#!/usr/bin/perl -w

=head1 NAME

parallel - build and execute shell command lines from standard input in parallel

=head1 SYNOPSIS

B<parallel> [-0cfgkqsuvxX] [-I str] [-j num] [command [arguments]] < list_of_arguments

=head1 DESCRIPTION

For each line of input B<parallel> will execute B<command> with the
line as arguments. If no B<command> is given the line of input is
executed.  B<parallel> can often be used as a substitute for B<xargs>
or B<cat | sh>.

Several lines will be run in parallel.

=over 9

=item I<command>

Command to execute.  If B<command> or the following arguments contain {}
every instance will be substituted with the input line. Setting a
command also invokes B<-f>.

If B<command> is given, B<parallel> will behave similar to B<xargs>. If
B<command> is not given B<parallel> will behave similar to B<cat | sh>.

=item B<-0>

Use NUL as delimiter.  Normally input lines will end in \n
(newline). If they end in \0 (NUL), then use this option. It is useful
for processing filenames that may contain \n (newline).

=item B<-c>

Line is a command.  The input line contains more than one argument or
the input line needs to be evaluated by the shell. This is the default
if B<command> is not set. Can be reversed with B<-f>.

=item B<-f>

Line is a filename.  The input line contains a filename that will be
quoted so it is not evaluated by the shell. This is the default if
B<command> is set. Can be reversed with B<-c>.

=item B<-g>

Group output.  Output from each jobs is grouped together and is only
printed when the command is finished. STDERR first followed by STDOUT.
B<-g> is the default. Can be reversed with B<-u>.

=item B<-I> I<string>

Use the replacement string I<string> instead of {}.

=item B<-j> I<N>

Run N jobs in parallel.  0 means as many as possible. Default is 10.

=item B<-j> I<+N>

Add N to the number of CPUs.  Run this many jobs in parallel. For
compute intensive jobs I<-j +0> is useful as it will run
number-of-cpus jobs in parallel.

=item B<-j> I<-N>

Subtract N from the number of CPUs.  Run this many jobs in parallel.
If the evaluated number is less than 1 then 1 will be used.

=item B<-j> I<N>%

Multiply N% with the number of CPUs.  Run this many jobs in parallel.
If the evaluated number is less than 1 then 1 will be used.

=item B<-k>

Keep sequence of output same as the order of input. If jobs 1 2 3 4
end in the sequence 3 1 4 2 the output will still be 1 2 3 4.

=item B<-q>

Quote B<command>.  This will quote the command line so special
characters are not interpreted by the shell. See the section
QUOTING. Most people will never need this.  Quoting is disabled by
default.

=item B<-s>

Silent.  The job to be run will not be printed. This is the default.
Can be reversed with B<-v>.

=item B<-u>

Ungroup output.  Output is printed as soon as possible. This may cause
output from different commands to be mixed. Can be reversed with B<-g>.

=item B<-v>

Verbose.  Print the job to be run. Can be reversed with B<-s>.

=item B<-x>

xargs. Insert as many arguments as the command line length permits. If
{} is not used the arguments will be appended to the line.  If {} is
used multiple times each {} will be replaced with all the arguments.

=item B<-X>

xargs with context replace. This works like B<-x> except if {} is part
of a word (like I<pic{}.jpg>) then the whole word will be repeated.

=back

=head1 EXAMPLE 1: Working as cat | sh. Ressource inexpensive jobs and evaluation

B<parallel> can work similar to B<cat | sh>. 

A ressource inexpensive job is a job that takes very little CPU, disk
I/O and network I/O. Ping is an example of a ressource inexpensive
job. wget is too - if the webpages are small.

The content of the file jobs_to_run:

  ping -c 1 10.0.0.1
  wget http://status-server/status.cgi?ip=10.0.0.1
  ping -c 1 10.0.0.2
  wget http://status-server/status.cgi?ip=10.0.0.2
  ...
  ping -c 1 10.0.0.255
  wget http://status-server/status.cgi?ip=10.0.0.255

To run 100 processes simultaneously do:

B<parallel -j 100 < jobs_to_run>

As there is not a B<command> the option B<-c> is default because the
jobs needs to be evaluated by the shell.

=head1 EXAMPLE 2: Working as xargs -n1. Argument appending

B<parallel> can work similar to B<xargs -n1>. 

To output all html files run:

B<find . -name '*.html' | parallel cat>

As there is a B<command> the option B<-f> is default because the
filenames needs to be protected from the shell in case a filename
contains special characters.

=head1 EXAMPLE 3: Compute intensive jobs and substitution

If ImageMagick is installed this will generate a thumbnail of a jpg
file:

B<convert -geometry 120 foo.jpg thumb_foo.jpg>

If the system has more than 1 CPU it can be run with number-of-cpus
jobs in parallel (-j +0). This will do that for all jpg files in a
directory:

B<ls *.jpg | parallel -j +0 convert -geometry 120 {} thumb_{}>

To do it recursively use B<find>:

B<find . -name '*.jpg' | parallel -j +0 convert -geometry 120 {} {}_thumb.jpg>

Notice how the argument has to start with {} as {} will include path
(e.g. running B<convert -geometry 120 ./foo/bar.jpg
thumb_./foo/bar.jpg> would clearly be wrong). It will result in files
like ./foo/bar.jpg_thumb.jpg. If that is not wanted this can fix it:

  find . -name '*.jpg' | \
  perl -pe 'chomp; $a=$_; s:/([^/]+)$:/thumb_$1:; $_="convert -geometry 120 $a $_\n"' | \
  parallel -c -j +0

Unfortunately this will not work if the filenames contain special
characters (such as space or quotes). If you have B<ren> installed this
is a better solution:

  find . -name '*.jpg' | parallel -j +0 convert -geometry 120 {} {}_thumb.jpg
  find . -name '*_thumb.jpg' | ren 's:/([^/]+)_thumb.jpg$:/thumb_$1:'


=head1 EXAMPLE 4: Substitution and redirection

This will compare all files in the dir to the file foo and save the
diffs in corresponding .diff files:

B<ls | parallel diff {} foo ">>B<"{}.diff>

Quoting of > is necessary to postpone the redirection. Another
solution is to quote the whole command:

B<ls | parallel "diff {} foo >>B<{}.diff">


=head1 EXAMPLE 5: Composed commands

A job can consist of several commands. This will print the number of
files in each directory:

B<ls | parallel 'echo -n {}" "; ls {}|wc -l'>

To put the output in a file called <name>.dir:

B<ls | parallel '(echo -n {}" "; ls {}|wc -l) >> B<{}.dir'>


=head1 EXAMPLE 6: Context replace

To remove the files I<pict0000.jpg> .. I<pict9999.jpg> you could do:

B<seq -f %04g 0 9999 | parallel rm pict{}.jpg>

You could also do:

B<seq -f %04g 0 9999 | perl -pe 's/(.*)/pict$1.jpg/' | parallel -x rm>

The first will run B<rm> 10000 times, while the last will only run
B<rm> as many times needed to keep the command line length short
enough (typically 1-2 times).

You could also run:

B<seq -f %04g 0 9999 | parallel -X rm pict{}.jpg>

This will also only run B<rm> as many times needed to keep the command
line length short enough.

=head1 EXAMPLE 7: Group output lines

When runnning jobs that output data, you often do not want the output
of multiple jobs to run together. B<parallel> defaults to grouping the
output of each job, so the output is printed when the job finishes. If
you want the output to be printed while the job is running you can use
B<-u>.

Compare the output of:

B<(echo foss.org.my; echo www.debian.org; echo www.freenetproject.org) | parallel traceroute>

to the output of:

B<(echo foss.org.my; echo www.debian.org; echo www.freenetproject.org) | parallel -u traceroute>


=head1 EXAMPLE 8: Keep order of output same as order of input

Normally the output of a job will be printed as soon as it
completes. Sometimes you want the order of the output to remain the
same as the order of the input. B<-k> will make sure the order of
output will be in the same order as input even if later jobs end
before earlier jobs.

B<(echo foss.org.my; echo www.debian.org; echo www.freenetproject.org) | parallel traceroute>

will give traceroute of foss.org.my, www.debian.org and
www.freenetproject.org, but it will be sorted according to which job
completed first.

To keep the order the same as input run:

B<(echo foss.org.my; echo www.debian.org; echo www.freenetproject.org) | parallel -k traceroute>

This will make sure the traceroute to foss.org.my will be printed
first.


=head1 QUOTING

For more advanced use quoting may be an issue. The following will
print the filename for each line that has exactly 2 columns:

B<perl -ne '/^\S+\s+\S+$/ and print $ARGV,"\n"' file>

This can be done by B<parallel> using:

B<ls | parallel "perl -ne '/^\\S+\\s+\\S+$/ and print \$ARGV,\"\\n\"'">

Notice how \'s, "'s, and $'s needs to be quoted. B<parallel> can do
the quoting by using option B<-q>:

B<ls | parallel -q  perl -ne '/^\S+\s+\S+$/ and print $ARGV,"\n"'>

However, this means you cannot make the shell interpret special
characters. For example this B<will not work>:

B<ls | parallel -q "diff {} foo >>B<{}.diff"> 

B<ls | parallel -q "ls {} | wc -l">

because > and | need to be interpreted by the shell.

If you get errors like:

B<sh: -c: line 0: syntax error near unexpected token>

then you might try using B<-q>.

If you are using B<bash> process substitution like B<<(cat foo)> then
you may try B<-q> and prepending B<command> with B<bash -c>:

B<ls | parallel -q bash -c 'wc -c <(echo {})'>

Or for substituting output:

B<ls | parallel -q bash -c 'tar c {} | tee >>B<(gzip >>B<{}.tar.gz) | bzip2 >>B<{}.tar.bz2'>

B<Conclusion>: To avoid dealing with the quoting problems it may be
easier just to write a small script and have B<parallel> call that
script.


=head1 LIST RUNNING JOBS

To list the jobs currently running you can run:

B<killall -USR1 parallel>

B<parallel> will then print the currently running jobs on STDERR.


=head1 COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS

If you regret starting a lot of jobs you can simply break B<parallel>,
but if you want to make sure you do not have halfcompleted jobs you
should send the signal B<-USR2> to B<parallel>:

B<killall -USR2 parallel>

This will tell B<parallel> to not start any new jobs, but wait until
the currently running jobs are finished.


=head1 DIFFERENCES BETWEEN xargs/find -exec AND parallel

B<xargs> and B<find -exec> offer some of the same possibilites as
B<parallel>. 

B<find -exec> only works on files. So processing other input (such as
hosts or URLs) will require creating these inputs as files. B<find
-exec> has no support for running commands in parallel.

B<xargs> deals badly with special characters (such as space, ' and
"). To see the problem try this:

touch important_file
touch 'not important_file'
ls not* | xargs rm

You can specify B<-0> or B<-d "\n">, but many input generators are not
optimized for using B<NUL> as separator but are optimized for
B<newline> as separator. E.g B<head>, B<tail>, B<awk>, B<ls>, B<echo>,
B<sed>, B<tar -v>, B<perl> (-0 and \0 instead of \n), B<locate>
(requires using -0), B<find> (requires using -print0), B<grep>
(requires user to use -z or -Z).

So B<parallel>'s newline separation can be emulated with:

B<cat | xargs -d "\n" -n1 I<command>>

B<xargs> can run a given number of jobs in parallel, but has no
support for running no_of_cpus jobs in parallel.

B<xargs> has no support for grouping the output, therefore output may
run together, e.g. the first half of a line is from one process and
the last half of the line is from another process.

B<xargs> has no support for keeping the order of the output, therefore
if running jobs in parallel using B<xargs> the output of the second
job cannot be postponed till the first job is done.

B<xargs> has no support for context replace, so you will have to create the 
arguments.

If you use a replace string in B<xargs> (B<-I>) you can not force
B<xargs> to use more than one argument.

Quoting in B<xargs> works like B<-q> in B<parallel>. This means
composed commands and redirection requires using B<bash -c>.

B<ls | parallel "wc {} >> B<{}.wc"> 

becomes 

B<ls | xargs -d "\n" -P10 -I {} bash -c "wc {} >>B< {}.wc">

and 

B<ls | parallel "echo {}; ls {}|wc"> 

becomes 

B<ls | xargs -d "\n" -P10 -I {} bash -c "echo {}; ls {}|wc">


=head1 DIFFERENCES BETWEEN mdm/middleman AND parallel

middleman(mdm) is also a tool for running jobs in parallel.

Here are the shellscripts of http://mdm.berlios.de/usage.html ported
to parallel use:

B<seq 1 19 | parallel -j+0 buffon -o - | sort -n >>B< result>

B<cat files | parallel -j+0 cmd>


=head1 BUGS

Filenames beginning with '-' can cause some commands to give
unexpected results, as it will often be interpreted as an option.

=head1 REPORTING BUGS

Report bugs to <bug-parallel@tange.dk>.

=head1 IDEAS

xargs dropin-replacement.
Implement the missing --features

monitor to see which jobs are currently running
http://code.google.com/p/ppss/

Accept signal INT to complete current running jobs but do not start
new jobs. Print out the number of jobs waiting to complete on
STDERR. Accept sig INT again to kill now. This seems to be hard, as
all foreground processes get the INT from the shell.

Distibute jobs to computers with different speeds/no_of_cpu using ssh
ask the computers how many cpus they have and spawn appropriately
according to -j setting. 
http://www.semicomplete.com/blog/geekery/distributed-xargs.html?source=rss20

=head2 -S

-S sshlogin[,sshlogin]

sshlogin is [user@]host or filename with list of sshlogin

What about copying data to/from remote host?



Parallelize so this can be done:
mdm.screen find dir -execdir mdm-run cmd {} \;
Maybe:
find dir -execdir parallel --communication-file /tmp/comfile cmd {} \;

=head2 Comfile

This will put a lock on /tmp/comfile. The number of locks is the number of running commands.
If the number is smaller than -j then it will start a process in the background ( cmd & ),
otherwise wait.

parallel --wait /tmp/comfile will wait until no more locks on the file

=head1 AUTHOR

Copyright (C) 2007-10-18 Ole Tange, http://ole.tange.dk

Copyright (C) 2008-2009 Ole Tange, http://ole.tange.dk


=head1 LICENSE

Copyright (C) 2007-2009 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.


=head1 DEPENDENCIES

B<parallel> uses Perl, and the Perl modules Getopt::Std, IPC::Open3,
Symbol, IO::File, POSIX, and File::Temp.


=head1 SEE ALSO

B<find>(1), B<xargs>(1)

=cut


use IPC::Open3;
use Symbol qw(gensym);
use IO::File;
use POSIX ":sys_wait_h";
use File::Temp qw/ tempfile tempdir /;
use Getopt::Std;
use strict;

my ($processes,$command);
getopts("0cdfgI:j:kqsuvxX") || die_usage();

# Defaults:
$Global::debug = 0;
$Global::processes_to_run = 10;
$command = undef;
$Global::verbose = 0;
$Global::grouped = 1;
$Global::keeporder = 0;
$Global::quoting = 0;
$Global::replacestring = '{}';
$Global::input_is_filename = (@ARGV);
$/="\n";

$Global::debug = (defined $::opt_d);
if(defined $::opt_x) { $Global::xargs = 1; }
if(defined $::opt_X) { $Global::Xargs = 1; }
if(defined $::opt_v) { $Global::verbose = 1; }
if(defined $::opt_s) { $Global::verbose = 0; }
if(defined $::opt_k) { $Global::keeporder = 1; }
if(defined $::opt_g) { $Global::grouped = 1; }
if(defined $::opt_u) { $Global::grouped = 0; }
if(defined $::opt_c) { $Global::input_is_filename = 0; }
if(defined $::opt_f) { $Global::input_is_filename = 1; }
if(defined $::opt_0) { $/ = "\0"; }
if(defined $::opt_q) { $Global::quoting = 1; }
if(defined $::opt_I) { $Global::replacestring = $::opt_I; }

if(@ARGV) { 
    if($Global::quoting) {
        $Global::command = join(" ", shell_quote(@ARGV)); 
    } else {
        $Global::command = join(" ", @ARGV); 
    }
}
# Needs to be done after setting $Global::command and $Global::command_line_max_len
# as '-x' influences the number of commands that needs to be run
if(defined $::opt_j) { $Global::processes_to_run = compute_number_of_processes($::opt_j); }

$Global::job_end_sequence=1;

init_run_jobs();
DoNotReap();
start_more_jobs();
ReapIfNeeded();
drain_job_queue();

#
# Generating the command line
#

sub generate_command_line {
    my $command = shift;
    my ($job_line,$last_good);
    my ($next_arg,@quoted_args,$arg_length);
    my ($number_of_substitution) = 1;
    my ($length_of_context) = 0;
    my ($length_of_command_no_args);
    if($Global::xargs or $Global::Xargs) {
	# Count number of {}'s on the command line
	$number_of_substitution = ($command =~ s/$Global::replacestring/$Global::replacestring/go);
	$number_of_substitution ||= 1;
    }
    if($Global::xargs) {
	my $c = $command;
	# remove all {}s
	$c =~ s/$Global::replacestring//go;
	$length_of_command_no_args = length($c);
    }
    if($Global::Xargs) {
	my $c = $command;
	while($c =~ s/(\S*$Global::replacestring\S*)//o) {
	    # Length of context minus the {}
	    $length_of_context += length($1) - 2;
	}
	$length_of_command_no_args = length($c);
    }

    while (defined($next_arg = get_next_arg())) {
	push (@quoted_args, $next_arg);
	if(not $Global::xargs and not $Global::Xargs) {
	    last;
	} else {
	    # Emulate xargs if there is a command and -x or -X is set
	    $arg_length += $number_of_substitution * (1 + length ($next_arg)) 
		+ $length_of_context;
	    # debug("arglen $arg_length = $number_of_substitution * (1 + length ($next_arg)) + $length_of_context\n");
	    my $job_line_length = $length_of_command_no_args + 1 + $arg_length;
	    # debug("linelen $job_line_length = $length_of_command_no_args + 1 + $arg_length\n");
	    if($job_line_length >= max_length_of_command_line()) {
		unget_arg(pop @quoted_args);
		if($quoted_args[0]) {
		    last;
		} else {
		    die ("Command line too long at $next_arg");
		}
	    }
	}
    }
    if(@quoted_args) {
	$job_line = $command;
	if(defined $job_line and $job_line =~/$Global::replacestring/o) {
	    # substitute {} with args
	    if($Global::Xargs) {
		# Context sensitive replace (foo{}bar with fooargsbar)
		while($job_line =~/$Global::replacestring/o) {
		    $job_line =~ /(\S*$Global::replacestring\S*)/ or die ("This should never happen"); 
		    my $wordarg = $1;
		    my @all_word_arg;
		    for my $arg (@quoted_args) {
			my $substituted = $wordarg;
			$substituted=~s/$Global::replacestring/$arg/go;
			push @all_word_arg, $substituted;
		    }
		    my $all_word_arg = join(" ",@all_word_arg);
		    my ($quoted_wordarg) = shell_quote($wordarg);
		    $job_line =~ s/$quoted_wordarg/$all_word_arg/;
		}
	    } else {
		# Normal replace {} with args
		my $arg=join(" ",@quoted_args);
		$job_line =~ s/$Global::replacestring/$arg/go;
	    }
	} else {
	    # append args
	    my $arg=join(" ",@quoted_args);
	    $job_line .= " $arg";
	}
	debug("Return jobline: $job_line\n");
    }
    return $job_line;
}

sub shell_quote {
    # Quote the string so shell will not expand any special chars
    my (@strings) = (@_);
    my $arg; 
    for $arg (@strings) {
	# what is the right thing to do about '-' at start of line?
	# maybe substitute with './'
	# so it is not regarded as -option.
	$arg =~ s/\\/\\\\/g;
	
	$arg =~ s/([\#\?\`\(\)\*\>\<\~\|\; \"\!\$\&\'])/\\$1/g;
	$arg =~ s/([\002-\011\013-\032])/\\$1/g;
	$arg =~ s/([\n])/'\n'/g; # filenames with '\n' is quoted using \'
    }
    return (@strings);
}

#
# Number of processes, filehandles, max length of command line
#

# Maximal command line length (for -x)

sub max_length_of_command_line {
    # Find the max_length of a command line
    # First find an upper bound
    if(not $Global::command_line_max_len) {
	my $len = 2;
	do {
	    $len += $len+1;
	} while (is_acceptable_command_line_length($len));
	# Then search for the actual max length between 0 and upper bound
	$Global::command_line_max_len = binary_find_max_length(0,$len);
    }
    return $Global::command_line_max_len;
}

sub binary_find_max_length {
    # Given a lower and upper bound find the max_length of a command line
    my ($lower, $upper) = (@_);
    if($lower == $upper or $lower == $upper-1) { return $lower; }
    my $middle = int (($upper-$lower)/2 + $lower);
    debug("$lower,$upper,$middle\n");
    if (is_acceptable_command_line_length($middle)) {
	return binary_find_max_length($middle,$upper);
    } else {
	return binary_find_max_length($lower,$middle);
    }
}

sub is_acceptable_command_line_length {
    # Test if a command line of this length can run
    # This is done using external perl script to avoid warning
    # (Can this be done prettier?)
    my $len = shift;
    my $testscript = q{'system ("true "."x"x$ARGV[0]); exit $?;'};
    debug("perl -e $testscript $len\n");
    system "perl -e $testscript $len";
    return not $?;
}

# Number of parallel processes to run

sub compute_number_of_processes {
    # Number of processes wanted and limited by system ressources
    my $opt_j = shift;
    my $wanted_processes = user_requested_processes($opt_j);
    debug("Wanted procs: $wanted_processes\n");
    my $system_limit = processes_available_by_system_limit($wanted_processes);
    debug("Limited to procs: $system_limit\n");
    return $system_limit;
}

sub processes_available_by_system_limit {
    # If the wanted number of processes is bigger than the system limits:
    # Limit them to the system limits
    # Limits are: File handles, number of input lines, processes, 
    # and taking > 1 second to spawn 10 extra processes 
    my $wanted_processes = shift;
    my $system_limit=0;
    my @command_lines=();
    my $next_command_line;
    my $more_filehandles;
    my $max_system_proc_reached=0;
    my $spawning_too_slow=0;
    my $time = time;
    my %fh;
    my @children;
    DoNotReap();

    # Reserve filehandles
    # perl uses 7 filehandles for something?
    # parallel uses 1 for memory_usage
    for my $i (1..8) {
	open($fh{"init-$i"},"</dev/null");
    }
    do {
	$system_limit++;

	# If there are no more command lines, then we have a process
	# per command line, so no need to go further
	$next_command_line = next_command_line();
	if(defined $next_command_line) { 
	    push(@command_lines, $next_command_line);
	}

	# Every simultaneous process uses 2 filehandles when grouping
	$more_filehandles = open($fh{$system_limit*2},"</dev/null") 
	    && open($fh{$system_limit*2+1},"</dev/null");

	# System process limit
	$system_limit % 10 or $time=time;
	my $child;
	if($child = fork()) {
	    push (@children,$child);
	} elsif(defined $child) {
	    # The child takes one process slot
	    # It will be killed later
	    sleep 100000;
	    exit;
	} else {
	    $max_system_proc_reached = 1;
	}
	debug("Time to fork ten procs ", time-$time, " process ", $system_limit);
	if(time-$time > 2) {
	    # It took more than 2 second to fork ten processes. We should stop forking.
	    # Let us give the system a little slack
	    debug("\nLimiting processes to: $system_limit-10%=".
		  (int ($system_limit * 0.9)+1)."\n");
	    $system_limit = int ($system_limit * 0.9)+1;
	    $spawning_too_slow = 1;
	}
    } while($system_limit < $wanted_processes 
	    and defined $next_command_line
	    and $more_filehandles
	    and not $max_system_proc_reached
	    and not $spawning_too_slow);
    if($system_limit < $wanted_processes and not $more_filehandles) {
	print STDERR ("Warning: Only enough filehandles to run ",
		      $system_limit, " jobs in parallel. ",
		      "Raising ulimit -n may help\n");
    }
    if($system_limit < $wanted_processes and $max_system_proc_reached) {
	print STDERR ("Warning: Only enough available processes to run ",
		      $system_limit, " jobs in parallel.\n");
    }
    if($system_limit < $wanted_processes and $spawning_too_slow) {
	print STDERR ("Warning: Starting 10 extra processes takes > 2 sec.\n",
		      "Limiting to ", $system_limit, " jobs in parallel.\n");
    }
    # Cleanup: Close the files
    for (values %fh) { close $_ }
    # Cleanup: Kill the children
    for my $pid (@children) {
	kill 15, $pid;
	waitpid($pid,0);
    }
    wait();
    # Cleanup: Unget the command_lines
    unget_command_line(@command_lines);
    return $system_limit;
}

sub enough_file_handles {
    # check that we have enough filehandles available for starting
    # another job
    if($Global::grouped) {
	my %fh;
	my $enough_filehandles = 1;
	# We need a filehandle for STDOUT and STDERR
	# open3 uses 2 extra filehandles temporarily
	for my $i (1..4) {
	    $enough_filehandles &&= open($fh{$i},"</dev/null");
	}
	for (values %fh) { close $_; }
	return $enough_filehandles;
    } else {
	return 1;
    }
}

sub user_requested_processes {
    # Parse the number of processes that the user asked for
    my $opt_j = shift;
    if(defined $opt_j) {
	if($opt_j =~ /^\+(\d+)$/) {
	    # E.g. -j +2
	    my $j = $1;
	    $processes = $j + no_of_cpus();
	} elsif ($opt_j =~ /^-(\d+)$/) {
	    # E.g. -j -2
	    my $j = $1;
	    $processes = no_of_cpus() - $j;
	} elsif ($opt_j =~ /^(\d+)\%$/) {
	    my $j = $1;
	    $processes = no_of_cpus() * $j / 100;
	} elsif ($opt_j =~ /^(\d+)$/) {
	    $processes = $1;
	    if($processes == 0) {
		# -j 0 = infinity (or at least close)
		$processes = 2**31;
	    }
	} else {
	    die_usage();
	}
	if($processes < 1) {
	    $processes = 1;
	}
    }
    return $processes;
}

sub no_of_cpus {
    if(not $Global::no_of_cpus) {
	my $no_of_cpus = (no_of_cpus_gnu_linux() || no_of_cpus_solaris());
	if($no_of_cpus) {
	    $Global::no_of_cpus = $no_of_cpus;
	} else {
	    warn("Cannot figure out no of cpus. Using 1");
	    $Global::no_of_cpus = 1;
	}
    }
    return $Global::no_of_cpus;
}

sub no_of_cpus_gnu_linux {
    my $no_of_cpus;
    if(-e "/proc/cpuinfo") {
	$no_of_cpus = 0;
	open(IN,"cat /proc/cpuinfo|") || return undef;
	while(<IN>) {
	    /^processor.*[:]/ and $no_of_cpus++;
	}
	close IN;
    }
    return $no_of_cpus;
}

sub no_of_cpus_solaris {
    if(-x "/usr/sbin/psrinfo") {
	my @psrinfo = `/usr/sbin/psrinfo`;
	if($#psrinfo >= 0) {
	    return $#psrinfo +1;
	}
    }
    if(-x "/usr/sbin/prtconf") {
	my @prtconf = `/usr/sbin/prtconf | grep cpu..instance`;
	if($#prtconf >= 0) {
	    return $#prtconf +1;
	}
    }
    return undef;
}


#
# Running and printing the jobs
#

sub init_run_jobs {
    # Remember the original STDOUT and STDERR
    open $Global::original_stdout, ">&STDOUT" or die "Can't dup STDOUT: $!";
    open $Global::original_stderr, ">&STDERR" or die "Can't dup STDERR: $!";
    $Global::running_jobs=0;
    $SIG{USR1} = \&ListRunningJobs;
    $SIG{USR2} = \&StartNoNewJobs;
}

sub next_command_line {
    my $cmd_line;
    if(@Global::unget_next_command_line) {
	$cmd_line = shift @Global::unget_next_command_line;
    } else {
	do {
	    $cmd_line = generate_command_line($Global::command);
	} while (defined $cmd_line and $cmd_line =~ /^\s*$/); # Skip empty lines
    }
    return $cmd_line;
}

sub unget_command_line {
    push @Global::unget_next_command_line, @_;
}

sub get_next_arg {
    my $arg;
    if(@Global::unget_arg) {
	$arg = shift @Global::unget_arg;
    } else {
	if(eof STDIN) {
	    return undef;
	}
	$arg = <STDIN>;
	chomp $arg;
	if($Global::input_is_filename) {
	    ($arg) = shell_quote($arg);
	}
    }
    debug("Next arg: ".$arg."\n");    
    return $arg;
}

sub unget_arg {
    push @Global::unget_arg, @_;
}

sub drain_job_queue {
    while($Global::running_jobs > 0) {
	debug("jobs running: $Global::running_jobs Memory usage:".my_memory_usage()."\n");
	sleep 1;
    }
}

sub start_more_jobs {
    my $jobs_started = 0;
    if(not $Global::StartNoNewJobs) {
	while($Global::running_jobs < $Global::processes_to_run
	      and
	      start_another_job()) {
	    $jobs_started++;
	}
    }
    return $jobs_started;
}

sub start_another_job {
    # Grab a job from @Global::command, start it 
    # and remember the pid, the STDOUT and the STDERR handles
    # If no more jobs: do nothing
    # Do we have enough file handles to start another job?
    if(enough_file_handles()) {
	my $command = next_command_line();
	if(defined $command) {
	    my %jobinfo = start_job($command);
	    $Global::running{$jobinfo{"pid"}} = \%jobinfo;
	    return 1;
	} else {
	    return 0;
	}
    } else {
	return 0;
    }
}

sub start_job {
    # Setup STDOUT and STDERR for a job and start it.
    my $command = shift;
    my ($pid,$out,$err,%out,%err,$outname,$errname,$name);
    if($Global::grouped) {
	# To group we create temporary files for STDOUT and STDERR
	# Filehandles are global, so to not overwrite the filehandles use a hash with new keys
	# To avoid the cleanup unlink the files immediately (but keep them open)
	$outname = ++$Global::TmpFilename;
	($out{$outname},$name) = tempfile(SUFFIX => ".par");
	unlink $name;
	$errname = ++$Global::TmpFilename;
	($err{$errname},$name) = tempfile(SUFFIX => ".par");
	unlink $name;

	open STDOUT, '>&', $out{$outname} or die "Can't redirect STDOUT: $!";
	open STDERR, '>&', $err{$errname} or die "Can't dup STDOUT: $!";
    }

    if($Global::verbose and not $Global::grouped) {
	print STDOUT $command,"\n";
    }
    $Global::running_jobs++;
    debug("$Global::running_jobs processes. Starting: $command\n");
    $pid = open3(gensym, ">&STDOUT", ">&STDERR", $command) || 
	die("open3 failed. Report a bug to <parallel\@tange.dk>\n");
    debug("started: $command\n");
    open STDOUT, ">&", $Global::original_stdout or die "Can't dup \$oldout: $!";
    open STDERR, ">&", $Global::original_stderr or die "Can't dup \$oldout: $!";

    $Global::job_start_sequence++;
    if($Global::grouped) {
	return ("seq" => $Global::job_start_sequence,
		"pid" => $pid,
		"out" => $out{$outname},
		"err" => $err{$errname},
		"command" => $command);
    } else {
	return ("seq" => $Global::job_start_sequence,
		"pid" => $pid, 
		"command" => $command);
    }
}

sub print_job {
    # Print the output of the jobs
    # Only relevant for grouping
    $Global::grouped or return;
    my $fhs = shift;
    if(not defined $fhs) {
	return;
    }
    my $out = $fhs->{out};
    my $err = $fhs->{err};
    my $command = $fhs->{command};

    debug(">>joboutput $command\n");
    if($Global::verbose and $Global::grouped) {
	print STDOUT $command,"\n";
	# If STDOUT and STDERR is merged, we want the command to be printed first
	# so flush to avoid STDOUT being buffered
	flush STDOUT;
    }
    seek $_, 0, 0 for $out, $err;
    if($Global::debug) {
	print STDERR "ERR:\n";
    }
    my $buf;
    while(sysread($err,$buf,1000_000)) {
	print STDERR $buf;
    }
    if($Global::debug) {
	print STDOUT "OUT:\n";
    }
    while(sysread($out,$buf,1000_000)) {
	print STDOUT $buf;
    }
    debug("<<joboutput $command\n");
    close $out;
    close $err;
}

#
# Signal handling stuff
#

sub ListRunningJobs {
    for my $v (values %Global::running) {
	print STDERR "parallel: ",$v->{'command'},"\n";
    }
}

sub StartNoNewJobs {
    $Global::StartNoNewJobs++;
}

sub CountSigChild {
    $Global::SigChildCaught++;
}

sub DoNotReap {
    # This will postpone SIGCHILD for sections that cannot be distracted by a dying child
    # (Racecondition)
    $SIG{CHLD} = \&CountSigChild;
}

sub ReapIfNeeded {
    # Do the postponed SIGCHILDs if any and re-install normal reaper for SIGCHILD
    # (Racecondition)
    if($Global::SigChildCaught) {
	$Global::SigChildCaught = 0;
	Reaper();
    }
    $SIG{CHLD} = \&Reaper;    
}

sub Reaper {
    # A job finished.
    # Print the output.
    # Start another job
    DoNotReap();
    $Global::reaperlevel++;
    my $stiff;
    debug("Reaper called $Global::reaperlevel\n");
    while (($stiff = waitpid(-1, &WNOHANG)) > 0) {
	if($Global::keeporder) {
	    $Global::print_later{$Global::running{$stiff}{"seq"}} = $Global::running{$stiff};
	    debug("died: $Global::running{$stiff}{'seq'}");
	    while($Global::print_later{$Global::job_end_sequence}) {
		debug("Found job end $Global::job_end_sequence");
		print_job($Global::print_later{$Global::job_end_sequence});
		delete $Global::print_later{$Global::job_end_sequence};
		$Global::job_end_sequence++;
	    }
	    delete $Global::running{$stiff};
	    $Global::running_jobs--;
	    start_more_jobs();
	} else {
	    print_job($Global::running{$stiff});
	    delete $Global::running{$stiff};
	    $Global::running_jobs--;
	    start_more_jobs();
	}
    }
    ReapIfNeeded();
    debug("Reaper exit $Global::reaperlevel\n");
    $Global::reaperlevel--;
}

#
# Usage
#

sub die_usage {
    usage();
    exit(1);
}

sub usage {
    print "Usage:\n";
    print "parallel [-0cdfgkqsuvxX] [-j num] [command [arguments]] < list_of_arguments\n";
}

#
# Debugging
#

sub debug {
    $Global::debug or return;
    if($Global::original_stdout) {
	print $Global::original_stdout @_;
    } else {
	print @_;
    }
}

sub my_memory_usage {
    use strict;
    use FileHandle;

    my $pid = $$;
    my $fh = FileHandle->new("</proc/$pid/stat");

    my $data = <$fh>;
    chomp $data;
    $fh->close;

    my @procinfo = split(/\s+/,$data);

    return $procinfo[22];
}

sub my_size {
    my @size_this = (@_);
    eval "use Devel::Size qw(size total_size)";
    if ($@) {
	return -1;
    } else {
	return total_size(@_);
    }
}


sub my_dump {
    my @dump_this = (@_);
    eval "use Data::Dump qw(dump);";
    if ($@) {
        # Data::Dump not installed
        eval "use Data::Dumper;";
        if ($@) {
            my $err =  "Neither Data::Dump nor Data::Dumper is installed\n".
                "Not dumping output\n";
            print STDERR $err;
            return $err;
        } else {
            return Dumper(@dump_this);
        }
    } else {
        eval "use Data::Dump qw(dump);";
        return (Data::Dump::dump(@dump_this));
    }
}

# Keep perl -w happy
$main::opt_u = $main::opt_c = $main::opt_f = $main::opt_q =
$main::opt_0 = $main::opt_s = $main::opt_v = $main::opt_g =
$main::opt_j = $main::opt_d = $main::opt_x = $main::opt_X =
$main::opt_k =
$Global::xargs = $Global::keeporder = 0;
